package org.erp.tools;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;


/**
 * 这是一个用来实现简单的 JDBC 操作的工具类
 */
public final class JdbcHelper {
	
	private static String connect ;
	
	private static  String driverClassName ;
	private static  String URL ;
	private static  String username ;
	private static  String password ;
	private static  boolean autoCommit ;
	private static  int isolation ;
	
	/** 声明一个 Connection 类型的 静态属性，用来缓存一个 已经存在的 连接对象 */
	private static  Connection conn ;
	
	/** 专门检查 缓存的 那个 连接是否 【不可以】被使用 */
	private static boolean invalid(){
		if( conn != null ){
			try {
				if( conn.isClosed() || !conn.isValid( 3 ) ){
					// 如过不可以被使用，返回 true
					return true ;
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
			// conn 既不是 null 且也没有关闭 ，且 isValid 返回 true，说明是可以使用的 ( 返回 false )
			return false ;
		} else {
			// conn 是 null ，不可用，返回 true
			return true ;
		}
	}
	
	/** 建立数据库连接 */
	public static Connection connect(){
		if( invalid() ){ // 如果连接是无效的
			// 加载驱动
			try {
				// 建立连接
				conn = DriverManager.getConnection(URL, username ,  password ) ;
			} catch (SQLException e) {
				System.out.println( "建立 " + connect + " 数据库连接失败 , " + e.getMessage() );
			}
		}
		return conn ;
	}
	
	/** 设置是否自动提交事务、设置事务的隔离级别 **/
	public static void transaction(){
		
		try {
			conn.setAutoCommit( autoCommit );
		} catch (SQLException e) {
			System.out.println( "设置事务的提交方式为 : " + ( autoCommit ? "自动" : "非自动" ) + " 时失败: " + e.getMessage()  );
		}
		
		if( isolation > -1 ){
			try {
				conn.setTransactionIsolation( isolation );
			} catch (SQLException e) {
				System.out.println( "设置事务的隔离级别时发生错误: " + e.getMessage()  );
			}
		}
		
	}
	
	/** 创建 Statement 对象 */
	public static Statement statement(){
		Statement st = null ;
		connect(); // 如果连接是无效的就重新连接
		transaction();//设置事务的提交方式 和 隔离级别
		
		try {
			st = conn.createStatement();
		} catch (SQLException e) {
			System.out.println( "创建 Statement 对象失败: " + e.getMessage() );
		}
		
		return st ;
	}
	
	/**
	 * 根据给定的带参数占位符的SQL语句，创建 PreparedStatement 对象
	 * @param SQL 带参数占位符的SQL语句
	 * @param autoGeneratedKeys 如果需要返回由数据库产生的键，传入 true
	 * @return 返回相应的 PreparedStatement 对象
	 */
	private static PreparedStatement prepare( String SQL , boolean autoGeneratedKeys ) {
		
		PreparedStatement ps = null ;
		connect(); 
		transaction();//设置事务的提交方式 和 隔离级别
		
		try {
			if( autoGeneratedKeys ) { 
				ps = conn.prepareStatement( SQL , Statement.RETURN_GENERATED_KEYS );
			} else {
				ps = conn.prepareStatement( SQL );
			}
		} catch (SQLException e) {
			System.out.println( "创建 PreparedStatement 对象失败: " + e.getMessage() );
		}
		
		return ps ;
		
	}
	
	/**
	 * 根据给定的 SQL 语句进行查询，如果SQL语句带有参数占位符，请按次序传入
	 * @param SQL 需要执行的SQL语句(可能带有参数占位符)
	 * @param params 如果需要执行的SQL语句中带有参数占位符，请依次序传入
	 * @return 返回查询结果对应的结果集
	 */
	public static ResultSet query( String SQL , Object... params ) {
		
		if( SQL == null || SQL.trim().isEmpty() || !SQL.trim().toLowerCase().startsWith( "select" ) ){
			throw new RuntimeException( "你的SQL语句为空或不是查询语句" );
		}
		
		ResultSet rs = null ;
		
		if( params.length > 0 ){ // 说明 有参数 传入，就需要处理参数
			// select * from students where id = ? and name = ?
			PreparedStatement ps = prepare( SQL , false );
			
			try{ 
				for( int i = 0 ; i < params.length ; i++ ){
					ps.setObject( i + 1 ,  params[ i ] );
				}
				
				rs = ps.executeQuery();
			} catch (SQLException e) {
				System.out.println( "执行SQL失败: " + e.getMessage() );
			}
			
		} else { // 说明没有传入任何参数，即 params.length 是 0 ( 不可能是 负数 )
			// select * from students 
			Statement st = statement();
			try {
				rs = st.executeQuery( SQL ) ; // 直接执行不带参数的 SQL 语句
			} catch (SQLException e) {
				System.out.println( "执行SQL失败: " + e.getMessage() );
			} 
		}
		
		return rs ;
		
	}
	
	/**
	 * 专门为 PreparedStatemet 的参数准备的，用来确定转换参数类型的方法
	 * @param o 需要转换的原来的数值
	 * @return 根据 JDBC 中的 PreparedStatemet 的需要，转换成相应的类型
	 */
	private static Object typeof( Object o ) {
		Object r = o ;
		
		if( o instanceof java.sql.Timestamp ){
			return r ;
		}
		
		// 将 java.util.Date 转成 java.sql.Date
		if( o instanceof java.util.Date ){
			java.util.Date d = (java.util.Date) o ;
			r = new java.sql.Date( d.getTime() );
			return r ;
		}
		
		// 将 Character 或 char 变成 String
		if( o instanceof Character || o.getClass() == char.class ){
			r = String.valueOf( o );
			return r ;
		}
		
		return r ;
	}
	
	/**
	 * 执行给定的SQL语句(可以带参数占位符)
	 * @param SQL 需要执行的执行 DDL 或 DML 语句(可以带参数占位符)
	 * @param params 如果将要执行的SQL语句带有参数占位符，请依次序传入
	 * @return 如果执行成功返回true
	 */
	public static boolean execute ( String SQL , Object... params ) {
		if( SQL == null || SQL.trim().isEmpty() || SQL.trim().toLowerCase().startsWith( "select" ) ){
			throw new RuntimeException( "你的SQL语句为空 或 不是 DDL 、DML 语句" );
		}
		
		boolean r = false ; // 表示 执行 DDL 或 DML 操作是否成功的一个标识变量
		
		// 获得 被执行的 SQL 语句的 前缀 ( 第一个单词 )
		SQL = SQL.trim();
		SQL = SQL.toLowerCase();
		String prefix = SQL.substring( 0 ,  SQL.indexOf( " " ) );
		
		String operation = "" ; // 用来保存操作类型的 变量
		
		// 根据前缀 确定操作
		switch ( prefix ) {
			case "create" :   operation = "创建表" ;    break ; 
			case "alter" :      operation = "修改表" ;  break ; 
			case "drop" :      operation = "删除表" ;  break ; 
			case "truncate" :  operation = "截断表" ;  break ; 
	
			case "insert" :  operation = "插入数据" ;   break ; 
			case "update" : operation = "更新数据" ;  break ; 
			case "delete" :  operation = "删除数据" ;  break ; 
		}
		 
		if( params.length > 0 ){ // 说明有参数
			PreparedStatement ps = prepare( SQL , false );
			
			Connection c = null ;
			try {
				c = ps.getConnection(); // 从 PreparedStatement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			} 
			
			try {
				
				for( int i = 0 ; i < params.length ; i++ ){
					Object p = params[ i ] ;
					p = typeof( p ) ;
					ps.setObject( i + 1 , p );
				}
				
				ps.executeUpdate();
				commit( c );
				r = true ;
			} catch (SQLException e) {
				System.out.println( operation + " 失败: " + e.getMessage()  );
				rollback( c );
			}
			 
		} else { // 说明没有参数
			
			Statement st = statement();
			Connection c = null ;
			try {
				c = st.getConnection(); // 从 Statement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			} 
			// 执行 DDL 或 DML 语句，并返回执行结果
			try {
				st.executeUpdate( SQL );
				commit(c); // 提交事务
				r = true ;
			} catch (SQLException e) {
				System.out.println( operation + " 失败: " + e.getMessage()  );
				rollback(c); // 回滚事务
			}
			
		}
		
		
		return r ;
	}
	
	/**
	 * 专门执行 INSERT 语句的方法，根据泛型参数确定返回值的类型
	 * 【注意】该方法仅用来执行插入单行记录的INSERT语句，不适用于执行批量插入
	 * @param SQL 需要执行的 INSERT 语句
	 * @param autoGeneratedKeys 指示是否需要返回由数据库产生的键
	 * @param params 将要执行的SQL语句中包含的参数占位符的 参数值
	 * @return 如果指定 autoGeneratedKeys 为 true 则返回由数据库产生的键；
	 *                如果指定 autoGeneratedKeys 为 false 则返回受当前SQL影响的记录数目
	 */
	public static int insert ( String SQL , boolean autoGeneratedKeys , Object... params ) {
		
		int var = -1 ;
		
		if( SQL == null || SQL.trim().isEmpty() ){
			throw new RuntimeException( "你没有指定SQL语句，请检查是否指定了需要执行的SQL语句" );
		}
		
		// 如果不是 insert 开头开头的语句
		if( !SQL.trim().toLowerCase().startsWith( "insert" ) ){
			System.out.println( SQL.toLowerCase() );
			throw new RuntimeException( "你指定的SQL语句不是插入语句，请检查你的SQL语句" );
		}
		
		// 获得 被执行的 SQL 语句的 前缀 ( 第一个单词 )
		SQL = SQL.trim();
		SQL = SQL.toLowerCase();
		 
		if( params.length > 0 ){ // 说明有参数
			PreparedStatement ps = prepare( SQL , autoGeneratedKeys );
			
			Connection c = null ;
			try {
				c = ps.getConnection(); // 从 PreparedStatement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			} 
			
			try {
				
				for( int i = 0 ; i < params.length ; i++ ){
					Object p = params[ i ] ;
					p = typeof( p ) ;
					ps.setObject( i + 1 , p );
				}
				
				int count  = ps.executeUpdate();
				
				if( autoGeneratedKeys ){ // 如果企望获得数据库产生的键
					ResultSet rs = ps.getGeneratedKeys(); // 获得数据库产生的键集
					if( rs.next() ){ // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt( 1 ); // 获得值并赋值给 var 变量
					}
				} else {
					var = count ; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
				
				commit( c );
				
			} catch (SQLException e) {
				System.out.println( "数据保存失败: " + e.getMessage()  );
				rollback( c );
			}
			 
		} else { // 说明没有参数
			
			Statement st = statement();
			Connection c = null ;
			try {
				c = st.getConnection(); // 从 Statement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			} 
			// 执行 DDL 或 DML 语句，并返回执行结果
			try {
				int count = st.executeUpdate( SQL );
				if( autoGeneratedKeys ){ // 如果企望获得数据库产生的键
					ResultSet rs = st.getGeneratedKeys(); // 获得数据库产生的键集
					if( rs.next() ){ // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt( 1 ); // 获得值并赋值给 var 变量
					}
				} else {
					var = count ; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
				commit(c); // 提交事务
			} catch (SQLException e) {
				System.out.println( "数据保存失败: " + e.getMessage()  );
				rollback(c); // 回滚事务
			}
			
		}
		
		return var ;
	}
	
	/** 提交事务 */
	private static void commit( Connection c ){
		if( c != null  &&  !autoCommit ){
			try {
				c.commit();
			} catch (SQLException e) {
				e.printStackTrace();
			} 
		}
	}
	
	/** 回滚事务 */
	private static void rollback( Connection c ){
		if( c != null  &&  !autoCommit ){
			try {
				c.rollback();
			} catch (SQLException e) {
				e.printStackTrace();
			} 
		}
	}
	
	/** 专门处理结果集的方法 */
	public static void show( ResultSet rs ) {
		
		if( rs != null ){
			
			try {
				ResultSetMetaData rsmd = rs.getMetaData(); // 结果集元数据
				final int columnCount = rsmd.getColumnCount() ;// 列数
				
				// 表头: 输出结果集中的 各个列名
				for( int i = 1 ; i <= columnCount ; i++ ){
					System.out.print( rsmd.getColumnLabel( i) + "\t\t");
				}
				System.out.println();
				
				// 数据: 将结果集中的数据以此输出
				while( rs.next() ) {
					
					for( int i = 1 ; i <= columnCount ; i++ ){
						System.out.print( rs.getObject( i ) + "\t\t");
					}
					System.out.println();
					
				}
				
			} catch (SQLException e) {
				e.printStackTrace();
			}
			
		}
		
	}
	
	/** 释放资源 **/
	public static void release( Object cloaseable ) {
		
		if( cloaseable != null ){
			
			if( cloaseable instanceof ResultSet ){
				ResultSet rs = (ResultSet) cloaseable ;
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			
			if( cloaseable instanceof Statement ){
				Statement st = (Statement) cloaseable ;
				try {
					st.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			} 
			
			if( cloaseable instanceof Connection ){
				Connection c = (Connection) cloaseable ;
				try {
					c.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			
		}
		
	}

}

